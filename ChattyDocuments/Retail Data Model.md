# Retail Data Model for Power BI Fabric Analytics

## Sales Data Enhancements

* **Multi-Line Orders (Order Header & Items):** To represent realistic transactions, the model separates order data into **Order Header** and **Order Item** tables. The **Order Header** table has one record per order (fields like *OrderID*, *OrderDate*, *CustomerID*, *StoreID*, *SalesRepID*, *PaymentType*, *PromotionCode*, *OrderTotal*), while the **Order Items** table has one record per product line in an order (fields such as *OrderID*, *ProductID*, *Quantity*, *UnitPrice*, *LineTotal*, etc.). This structure simulates multi-line purchases – for example, an order might have several different products – and allows analysis at both the order level and the item level. The OrderID serves as a link between the two tables. This design is true to retail systems (where an order can contain multiple items) and makes it easy to calculate metrics like average items per order or basket composition.

* **Returns and Refunds:** The sales model is extended to capture merchandise returns, ensuring the full sales lifecycle is represented (from purchase to potential return). One approach is a dedicated **Sales Returns** fact table recording each return event. This table might include *ReturnID*, reference to the original *OrderID* (and possibly *OrderItemID*), *ReturnDate*, *ProductID*, *CustomerID*, *StoreID*, *QuantityReturned*, *RefundAmount*, and *ReturnReason*. For instance, if a customer returns a defective item, the return table would log the item, quantity, and reason. (Alternatively, returns could be recorded in the sales fact with negative quantities and a flag, but a separate table simplifies return-specific analysis.) Including returns data enables valuable analysis of return rates, reasons, and their impact on net sales. Retailers can see, for example, what percentage of sold items are returned and identify problem products or categories.

* **Promotions and Discounts:** Sales data now incorporates promotions to reflect real-world discounting. Each order can have a **PromotionCode** (coupon or campaign code) applied, stored in the Order Header. This links to a new **Promotion** dimension table that details each promotion (e.g., *PromotionCode*, *Description*, *DiscountType* – percent or fixed amount, *DiscountValue*, *StartDate*, *EndDate*, etc). By capturing promotion usage, analysts can determine which sales were influenced by marketing campaigns or special offers. For example, if an order used a “SPRING2025” promo code, the model links that order to the promotion’s details (like “Spring 2025 Sale – 10% off”). This supports analyses such as total sales uplift from promotions, or comparing average order value with vs. without a promo. (If multiple promotions can apply to one order or line, the model could allow a many-to-many bridge, but for simplicity we assume one primary promo code per order in this schema.)

* **Payment Methods:** To better reflect how customers pay, the Order Header includes a **PaymentType** field indicating the payment method used (for example, *Credit Card*, *Cash*, *Mobile Wallet*, *Gift Card*). This ties to a **Payment Method** dimension table (with fields like *PaymentTypeID* and *PaymentTypeName*). Tracking payment type allows analysis of sales by payment mode (useful for finance or operations – e.g. seeing the share of credit card vs cash sales). It also helps identify trends like increased use of digital wallets or the need to support new payment options. For instance, one could filter sales to see revenue from credit cards vs. cash transactions in stores.

* **Sales Representative Attribution:** We add a **SalesRepID** on the Order Header to associate each sale with the employee or sales representative who facilitated it. The **Sales Rep** dimension (or more general *Employee* dimension) contains fields like *SalesRepID*, *RepName*, *Role*, and possibly *StoreID/Region* for their location or territory. This enhancement is crucial for scenarios like commissioned sales or B2B retail, where analyzing performance by salesperson is important. With this, the business can evaluate metrics per rep – e.g. total sales, number of orders, or average order value by rep – and identify top performers or training needs. It also lays the groundwork for integrating with CRM (since reps are involved in both sales and customer interactions).

**Example – Order and Return:** *Order #1001 (Order Header) shows Customer #C123 purchased 3 items on 2025-07-15 at Store #10, assisted by Rep #R45, paid by Credit Card, using promo SPRING2025 (10% off). The Order Items table then lists the 3 line items (Product #P1, qty 2; Product #P7, qty 1; Product #P9, qty 5, each with price and line total). A week later, the customer returns 1 unit of Product #P9 due to damage – the Returns table logs a record with Order #1001, Product #P9, Quantity 1, reason “Damaged – customer return”, and the refund amount.* This illustrates how the expanded model can record the full cycle of a sale and its post-sale adjustment.

## Operations Data Enhancements

* **Inventory/Operations Event Tracking:** Beyond sales, the model now includes a fact table for key **inventory and operational events**. This **InventoryEvents** fact table captures incidents like restocking and loss, with each record describing a single event. Notable *EventType* values include:

  * **Reorder Request** – e.g. when stock for a product falls below its threshold and a reorder is triggered.
  * **Vendor Delivery** – when new stock is delivered from a supplier (inventory inbound).
  * **Damaged Goods** – when items are found damaged (and thus removed from salable inventory).
  * *(Additional types could be “Stock Adjustment”, “Inventory Count” discrepancies, etc., but we focus on the three mentioned.)*

  Common fields: *EventID*, *EventTypeID* (FK to an **Event Type** dimension listing the above categories), *EventDate*, *ProductID*, *StoreID*, *Quantity*, and possibly *SupplierID* (especially relevant for deliveries) and *EmployeeID* (who logged the event, if applicable). For example, a record might indicate that on 2025-07-20, Store #10 created a Reorder Request for Product #P1 with quantity 50, after dropping below the reorder level. Another record could show that on 2025-07-25, a Vendor Delivery of 50 units of Product #P1 was received at Store #10 from Supplier #S88. By logging these events, the retailer can analyze operational efficiency: How often are reorders happening for each product? Which stores have the most damage incidents? How does delivery volume vary by supplier or season? These operational metrics can then be correlated with sales (e.g., frequent reorders might indicate a hot-selling item, or high damages might flag a handling issue). It provides visibility into the supply chain portion of the business, not just sales.

* **Product Master Data Expansion:** The **Product** dimension is enriched with additional attributes to support inventory and operations analysis. New fields in the Product master include:

  * *ProductName* – human-readable name of the product (e.g., “Wireless Mouse Model X”).
  * *Category* – a category or hierarchy label (e.g., “Electronics > Accessories”). This can be a simple field or a key to a separate **Product Category** table if needed for a hierarchy.
  * *SupplierID* – a link to a **Supplier** dimension indicating the primary vendor or manufacturer for this product.
  * *ReorderLevel* – an integer threshold for stock quantity at which point the product should be reordered to replenish stock. This is a crucial parameter in inventory management; for instance, if *ReorderLevel = 20*, the InventoryEvents fact would generate a Reorder Request event whenever the store’s inventory for that item drops to 20 or below. (This threshold might be determined by lead time and demand – a *“smart reorder point”* that uses sales data to prevent stockouts.)
  * *UnitCost* (optional) – cost at which the retailer acquires the item from supplier (useful for profit calculations).
  * *UnitPrice* (optional) – standard selling price to customers (could help in analysis or be stored in a separate pricing fact if prices vary).
  * *Status* (optional) – e.g., “Active”, “Discontinued” to know if item is currently sold.

  By expanding product attributes, analysts can do more granular slice-and-dice. For example, they might filter inventory events or sales by product category (how many reorders for Electronics vs. Clothing) or analyze supplier performance (if Supplier #S88’s products often hit reorders or have damage incidents). Supplier info in the product table (via SupplierID) allows integration with delivery events (each delivery event has a supplier). The *ReorderLevel* allows scenario analysis of stock levels relative to that target. All these additions make the data model more realistic for a retail business, where product metadata (category, supplier, cost, etc.) is essential for comprehensive analysis.

* **Store Master Data Expansion:** The **Store** (or Location) dimension is also enhanced to capture key operational details of retail outlets:

  * *StoreName* – e.g., “Downtown Outlet” or store code/number.
  * *Region* – the region or market the store belongs to (for example, *North*, *South*, *East*, *West* regions, or states/provinces). This helps analyze performance by geography (regional sales comparisons) and manage region-based operations (like logistics or regional managers).
  * *SquareFootage* – physical size of the store in square feet (or square meters). This is a proxy for the store’s capacity and can be used to compute metrics like sales per square foot – a common retail KPI to gauge how efficiently space is used.
  * *StoreType* (optional) – e.g., *“Retail Store”, “Outlet”, “Warehouse”*. This could differentiate between sales outlets versus distribution centers. In our case, the *Store* dimension might include both actual stores and possibly a warehouse or online channel as distinct entries (so that online sales or warehouse inventory events can be tracked similarly).
  * *OpeningDate* (optional) – date the store opened (useful for context or cohort analysis).

  These attributes enrich analytics by allowing filtering/aggregating by store characteristics. For example, one could compare sales by region or see if smaller stores (low square footage) have higher returns percentage than larger stores. Or analyze inventory deliveries by store size (perhaps larger stores get bigger deliveries). In a realistic scenario, knowing store size and region is very important for planning (inventory allocation, staff planning, etc.). The model’s store master ensures these factors are available for analysis.

*(Both Product and Store are relatively small tables, appropriate for a free-tier deployment – e.g., dozens or a few hundred products, and a dozen or two stores – but with rich columns to simulate a full-scale retail master data setup.)*

## CRM Enhancements

* **Customer Interaction History:** To integrate customer relationship management data, we introduce a **Customer Interactions** fact table logging all touchpoints with customers. Each record represents an interaction (or communication) between the company and a customer. Key fields include *InteractionID*, *CustomerID* (who was contacted or who contacted us), *InteractionDate*, *InteractionType*, and *SalesRepID* (which staff member or sales rep handled the interaction). An **Interaction Type** dimension defines the mode or channel of interaction, with values such as “Email”, “Phone Call”, “Store Visit”, “Online Chat” etc. For example, if a salesperson calls a customer to follow up on a purchase, we record an entry: InteractionType = Phone Call, SalesRep = that salesperson, Date = today’s date, Customer = that customer. If a customer visits a store and engages with the help desk, that could be logged as an interaction of type “In-Store Visit”. We also track *Lead Source* for new customers – this indicates how the customer first came into our CRM or sales funnel. **Lead Source** could be stored in the Customer dimension (e.g., Customer #C123 has LeadSource “Facebook Ad” or “Store Walk-In”), or as an attribute on the first interaction. Storing it in the Customer table (as a one-time attribute) is simpler: it might have values like “Online Ad”, “Referral”, “Organic Search”, “Trade Show”, etc., showing the origin of the customer’s first engagement.

  With interaction history in place, the business can analyze customer engagement levels: e.g., how many touches (emails/calls) each customer receives, response rates per channel, or how interactions drive sales. This is especially useful for integrated analytics – for instance, comparing groups of customers who receive high-touch follow-ups vs. those who don’t, or identifying which channels are most effective for reaching customers (perhaps email vs phone). It also helps customer service and marketing teams: they can find all interactions with a customer in one place or measure the workload of reps (how many calls each rep makes, etc.). The fact table can remain small (since even a few hundred interactions can illustrate patterns) and still provide realistic CRM insight.

* **Customer Segmentation & Attributes:** The **Customer** dimension is extended to include important segmentation flags and assignments that reflect CRM insights:

  * **High-Value Customer** – a boolean flag or a category (e.g., VIP tier) indicating a customer with high lifetime value or premium status. For example, you might flag customers whose total purchases exceed a certain amount as high-value. In analytics, this flag allows easy filtering of the “best” customers. Many retail CRM strategies focus on these top-tier customers, and having it in the model supports analysis like “high-value customers’ average order frequency vs. others” or targeted marketing.
  * **At-Risk of Churn** – a flag for customers who haven’t purchased in a long time or show signs of disengagement. This could be set by some criteria (e.g., no purchases or interactions in 12 months). Including it enables analysis of churn patterns – for instance, do at-risk customers have lower interaction counts or smaller past purchases? It’s useful for retention efforts, where the business can easily list all at-risk customers and see their profiles.
  * **Campaign Respondent** – a flag (or count) indicating whether the customer has responded to recent marketing campaigns. For instance, if the customer clicked a link in a campaign email or used a promotion code from a specific campaign, we mark them as a respondent. This is valuable for measuring campaign reach: we can segment sales or revenue by those who are campaign respondents vs. not, or check if campaign respondents tend to have higher future purchase rates. It effectively ties the marketing data to the customer record.
  * **Lead Source** – as mentioned above, an attribute capturing how the customer was acquired (e.g., “Referral”, “Social Media Ad”, “In-Store Signup”). This helps in analyzing which acquisition channels produce the most valuable customers. For example, perhaps “Referral” leads have higher retention than “Cold Call” leads – now we can quantify that.
  * **Assigned Sales Rep** – a field linking the customer to their account manager or sales representative responsible. In many retail contexts (especially B2B or higher-end retail), each customer might be assigned to a rep or a store. By storing SalesRepID on the customer, we can analyze customer value by rep, or ensure that when an interaction happens, we know which rep owns that relationship. It also integrates with the Sales Rep dimension used in sales facts.

  With these enhancements, the Customer table moves beyond basic demographic info to a rich profile for each customer. It supports a 360-degree customer view: we can filter customers who are high-value and see how many interactions they’ve had; or find how many at-risk customers responded to the last campaign, etc. This mirrors real CRM systems where customers are scored and tagged for targeted strategies. All these fields (HighValue, AtRisk, etc.) can be boolean or small text fields, so they add depth without heavy data volume.

**Example – Customer Profile:** *Customer #C123: Jane Doe, Lead Source = “Website Signup”, HighValue = Yes (lifetime spend \$10k), AtRisk = No, CampaignRespondent = Yes (clicked Spring Promo email), AssignedRep = R45. In the interactions fact, she has 3 records: an Email on 2025-06-01 (welcome email), a Phone Call on 2025-06-15 (Rep R45 follow-up), and an In-Store Visit on 2025-07-10 (personal shopping appointment). In the sales facts, she has 4 orders in the past year, two of which used promotion codes.* – This illustrates how the enriched Customer dimension and Interaction log give a full picture of Jane’s journey, which analysts can use to tailor marketing or measure the effectiveness of CRM efforts.

## Data Modeling Considerations

* **Schema Structure – Facts & Dimensions:** The expanded model is organized as a **star schema** for analytics, which is well-suited for Power BI. Fact tables represent business events (transactions or interactions), and dimension tables represent the context (entities like customers, products, stores, etc. with their attributes). Each fact table has a defined grain (the lowest level of detail captured) and foreign keys linking to the relevant dimensions. For example, the grain of the Order Items fact is an individual sold product line (one line per product per order), and it includes foreign keys for *ProductID*, *CustomerID*, *StoreID*, *DateID*, *SalesRepID*, *PromotionCode*, *PaymentTypeID*, etc. All dimension tables have a primary key (often a surrogate integer) that is referenced by the fact tables. This design ensures one-to-many relationships from dimensions to facts, optimizing it for Power BI’s in-memory engine. The main tables and their roles are:

  **Fact Tables (Events/Transactions):**

  * **FactOrderItems** – Detailed sales transactions at the line-item level (each row is one product on one order). Measures might include Quantity, LineTotal (after discount), and possibly UnitCost and UnitPrice. Foreign keys: OrderID (also to Order Header or as a degenerate dimension), ProductID, CustomerID, StoreID, DateID, SalesRepID, PromotionCode, PaymentTypeID.
  * **FactOrderReturns** – (If implemented separately) Return transactions at the item level. Each row represents a returned item. Measures: Return Quantity, RefundAmount. Links to dimensions: ProductID, CustomerID, StoreID, DateID, plus maybe a ReturnReason dimension and the original Order (as a reference).
  * **FactInventoryEvents** – Inventory/operations events. Each row is an event like a reorder or delivery. Measures: event count (could just be implicit as each row = 1 event) and quantities (e.g., units reordered, units damaged). Links: ProductID, StoreID (or LocationID; could be a warehouse), DateID, SupplierID, EventTypeID, EmployeeID (if tracking who logged it).
  * **FactCustomerInteractions** – CRM interaction events. Each row is one interaction (contact or touchpoint). Measures are usually counts (each row is one interaction, but one could add duration of call, etc., if available). Links: CustomerID, DateID, SalesRepID (the rep or agent), InteractionTypeID, and possibly StoreID if, say, in-store visits are logged against a store location.

  **Dimension Tables (Master Data & Attributes):**

  * **DimCustomer** – Customer master records. Key: CustomerID. Attributes: Name, contact info, demographics (if any), plus CRM flags like HighValue, AtRisk, CampaignRespondent, LeadSource, AssignedRepID, etc. Possibly also a join date or loyalty tier.
  * **DimProduct** – Product master. Key: ProductID (SKU or surrogate). Attributes: Name, Category, SupplierID, ReorderLevel, UnitCost, UnitPrice, etc.
  * **DimStore** – Store/location master. Key: StoreID. Attributes: StoreName, Region, SquareFootage, StoreType, etc. (Could also include Address, City, but not required for our analysis needs.)
  * **DimSalesRep** – Sales representatives or employees. Key: SalesRepID. Attributes: Rep Name, Role (e.g., Sales Associate, Manager), StoreID or Region (if reps are tied to a store or territory), maybe HireDate or other HR info if needed. This dimension is used for both sales (who sold) and CRM (who interacted).
  * **DimPromotion** – Promotion/campaign details. Key: PromotionCode (or a surrogate PromotionID). Attributes: Description, DiscountType (percent/amount), DiscountValue, StartDate, EndDate, maybe CampaignName or Channel. This lets us categorize promotions (e.g., “Summer Sale” vs “Clearance Coupon”).
  * **DimPaymentType** – Payment methods. Key: PaymentTypeID. Attributes: PaymentType (text like “Cash”, “Visa”, “PayPal”). Possibly a Category (e.g., “Credit Card” as a category vs specific card types). This is a small static dimension.
  * **DimSupplier** – Supplier or vendor information. Key: SupplierID. Attributes: Supplier Name, perhaps Location or Contact. This links to products and events (deliveries).
  * **DimDate** – Date (calendar) dimension. Key: DateID (often an integer YYYYMMDD). Attributes: full date, year, quarter, month, week, day of week, etc., for time series analysis. All fact tables with a date link to this to enable consistent date-based slicing (e.g., compare sales vs. returns by month).
  * **DimInteractionType** – (for CRM) Key: InteractionTypeID, with values like Email, Call, Visit, etc.
  * **DimEventType** – (for Inventory events) Key: EventTypeID, with values Reorder, Delivery, Damage, etc.
  * **DimReturnReason** – (optional for returns) Key: ReasonID, with values like Damaged, Defective, BuyerRemorse, etc., if analyzing why items are returned.

  All these tables are modeled at a granularity that keeps data volumes moderate. For instance, DimProduct might have 100 products, DimCustomer 1,000 customers, FactOrderItems maybe 10,000 rows (representing, say, a couple thousand orders with multiple lines each), and the other fact tables even fewer events. This is enough to be realistic for analysis but is small enough for easy handling.

* **Integration Points:** A major benefit of this schema is how **Sales, Operations, and CRM data interconnect via shared dimensions**, providing a holistic view of the retail business. Some key integration points are:

  * **Product**: The same DimProduct serves sales and ops. The sales fact tells us how much of each product sold, while the inventory events fact tells us how often that product was reordered or had issues. This means an analyst can, for example, pick a product and see both its sales performance and all related operational events (stockouts, deliveries) in one model. If a product sells extraordinarily well and frequently hits the *ReorderLevel*, the data will show a pattern of high sales in FactOrderItems alongside many “Reorder Request” entries in FactInventoryEvents for that product.
  * **Customer**: The Customer dimension links sales and CRM. We can analyze a single customer’s journey or aggregate behavior across customers. For instance, we could filter on *HighValue = Yes* in DimCustomer and then look at their total sales (from FactOrderItems) versus how many interactions they had (from FactCustomerInteractions). This unified view answers questions like “Do high-value customers engage more with our CRM?” or “What is the repeat purchase rate for customers who received a follow-up call?”. Without an integrated model, that analysis would be siloed.
  * **Store/Location**: Store is common to sales (brick-and-mortar sales happen at a store) and to inventory events (deliveries and damages are logged at a store or warehouse). This allows store-level P\&L style analysis. For example, for Store #10, one could pull total sales, total returns, and number of inventory issues or reorders, to assess overall performance and operational efficiency of that store. If a particular region’s stores are seeing many *Damaged Goods* events and also high return rates, management can spot that pattern in this combined model.
  * **SalesRep/Employee**: Sales reps are involved in both making sales and managing customer relationships. By using a common SalesRep dimension, we can see, for example, that Rep #R45 had \$500k sales this quarter (from FactOrderItems) and also made 50 customer calls (from FactCustomerInteractions). Integration allows evaluating whether rep activity correlates with sales success, or ensuring that high-value clients are assigned to reps and given appropriate attention. It also helps in crediting sales to the right person and analyzing commissions or training needs.
  * **Promotion/Campaign**: Promotions primarily link to sales (we capture which orders used which promo). This can be combined with the CRM data: the *CampaignRespondent* flag in DimCustomer and the Promotion usage in FactOrderItems together show marketing effectiveness. For instance, we can identify customers who responded to a campaign and see if they redeemed the corresponding promo code in a purchase – connecting marketing efforts to actual sales. (If we had a separate marketing campaign dimension, we could integrate that as well, but in this model promotions serve as a proxy for marketing initiatives.) Promotion data as a dimension also lets us aggregate sales by promotion (e.g., total revenue generated by the “SPRING2025” campaign).
  * **Date/Time**: Every fact is tied to the Date dimension, which means we can create synchronized timelines of different activities. For example, on a timeline, plot daily sales, daily returns, daily reorder events, and daily customer interactions together. This could reveal insights such as a spike in returns following a particular promotion, or increased customer service calls after a major sale event. Using a common calendar across sales, ops, and CRM ensures that comparisons by month/quarter, seasonality analysis, and time intelligence are consistent.

  In summary, the expanded schema breaks down data silos. A question like *“How did our operations handle the surge in sales from our holiday promotion, and what was the impact on customer satisfaction?”* can be answered by looking at promotion-driven sales in FactOrderItems, inventory deliveries/reorders in FactInventoryEvents around that time, and perhaps customer interactions or returns after the holiday – all within one model. This aligns with best practices of a unified retail data warehouse where **transactions, inventory, and customer data are analyzed together** for deeper insights.

* **Deployment in Power BI Fabric (Free Tier Friendly):** This data model is designed to be rich in content yet remain small in size, which makes it suitable for **Microsoft Fabric and Power BI free-tier usage**. We focused on adding **breadth (more tables and fields)** rather than extreme volume. This means the data can be easily managed as a set of small files or queries:

  * *Data Volume:* The tables can be populated with realistic but limited datasets (for example, a few thousand order lines, a few hundred customers, etc.). This keeps the overall dataset well within free-tier limits (which typically restrict the size of datasets). Because the schema is a star schema, it compresses well and queries efficiently even at modest scales.
  * *OneDrive/GitHub Integration:* Each table (dimension or fact) can be stored as a separate CSV or Excel file. These files can live in OneDrive or SharePoint (or even on GitHub as raw CSVs) and be connected to Power BI. Power BI Desktop and Fabric can **connect to OneDrive files via web URLs** – for example, using the *Get Data -> Web* connector pointing at the raw file link. This allows easy deployment and refresh: you could update the CSV in OneDrive and have Power BI refresh from it. GitHub Pages (or raw GitHub links) similarly can host CSVs publicly that Power BI can consume. In Fabric’s OneLake, you could also drop these files into a lakehouse and use shortcuts, but using OneDrive or GitHub is straightforward for a free user. The key is that the schema is simple to serialize as files.
  * *SQL Option:* Alternatively, since Fabric allows a free-tier Warehouse (SQL endpoint) in the cloud, one could upload this schema into a Fabric Warehouse by executing CREATE TABLE statements and inserting the sample data. The dimensional model could then be queried with Fabric’s SQL or used as a dataset source. The content is small enough that even an Embedded or free SQL on-demand could handle it.
  * *Organization and Documentation:* We have clearly defined keys and relationships, which makes setting up the Power BI **data model relationships** easy. For deployment, one would ensure that each fact table has the proper foreign key columns that correspond to the primary key of the dimension tables. In Power BI Desktop model view, you’d simply connect CustomerID in FactOrderItems to CustomerID in DimCustomer, and so on for each link. Because our table names and field names are intuitive (e.g., DateID in facts to Date table), it’s straightforward to create the relationships.
  * *Example Data and Schema Diagrams:* Along with this description, sample records could be provided for each table to illustrate the content (as we did in examples above). Schema diagrams can also be sketched to show the star schema – for example, a central FactOrderItems with arrows out to Product, Customer, Store, etc. – which could be easily created in a tool or even drawn and embedded if needed. Such a diagram would help during deployment to ensure all links are made correctly.

In conclusion, the enhanced data model encompasses a realistic range of retail data: **multi-channel sales transactions, returns, promotional influences, inventory operations, and customer relationship metrics**. It remains implementable on Power BI Fabric’s free tier by keeping the data volumes modest and using easily accessible storage like OneDrive or GitHub. This design provides a rich playground for analysis, allowing a retailer (or a Power BI developer) to gain insights into sales trends, inventory dynamics, and customer behavior all in one integrated solution. With proper sample data, one could deploy this model and immediately start slicing data – for instance, filtering to high-value customers and seeing their sales and returns across regions and time, or analyzing how a spike in sales due to a promotion impacted stock reorders and customer service interactions. The schema is both **comprehensive and practical**, striking a balance between depth of realism and ease of use for analytics.

